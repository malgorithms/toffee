// Generated by CoffeeScript 1.3.3
(function() {
  var engine, fs, path, states, tweakables, util, utils, view, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  view = require('./view').view;

  _ref = require('./consts'), states = _ref.states, tweakables = _ref.tweakables;

  utils = require('./utils');

  fs = require('fs');

  path = require('path');

  util = require('util');

  engine = (function() {

    function engine(options) {
      this._fn_partial = __bind(this._fn_partial, this);

      this._fn_snippet = __bind(this._fn_snippet, this);

      this._inlineInclude = __bind(this._inlineInclude, this);

      this.run = __bind(this.run, this);

      this.render = __bind(this.render, this);
      options = options || {};
      this.verbose = options.verbose || false;
      this.minimize = options.minimize || false;
      this.prettyPrintErrors = options.prettyPrintErrors != null ? options.prettyPrintErrors : true;
      this.prettyLogErrors = options.prettyLogErrors != null ? options.prettyLogErrors : true;
      this.autoEscape = options.autoEscape != null ? options.autoEscape : true;
      this.additionalErrorHandler = options.additionalErrorHandler || null;
      this.viewCache = {};
      this.fsErrorCache = {};
    }

    engine.prototype._log = function(o) {
      var _ref1;
      if (this.verbose) {
        if ((_ref1 = typeof o) === "string" || _ref1 === "number" || _ref1 === "boolean") {
          return console.log("toffee: " + o);
        } else {
          return console.log("toffee: " + (util.inspect(o)));
        }
      }
    };

    engine.prototype.render = function(filename, options, cb) {
      return this.run(filename, options, cb);
    };

    engine.prototype.run = function(filename, options, cb) {
      /*
          "options" contains the pub vars and may contain special items:
              layout:                  path to a template expecting a body var (express 2.x style, but for use with express 3.x)
              __toffee.dir:            path to look relative to
              __toffee.parent:         parent file
              __toffee.noInheritance:  if true, don't pass variables through unless explicitly passed
              __toffee.autoEscape:     if set as false, don't escape output of #{} vars by default
      */

      var err, k, layout_options, res, v, _ref1, _ref2, _ref3, _ref4;
      if (!(options.prettyPrintErrors != null)) {
        options.prettyPrintErrors = this.prettyPrintErrors;
      }
      if (!(options.prettyLogErrors != null)) {
        options.prettyLogErrors = this.prettyLogErrors;
      }
      if (!(options.additionalErrorHandler != null)) {
        options.additionalErrorHandler = this.additionalErrorHandler;
      }
      if (!(options.autoEscape != null)) {
        options.autoEscape = this.autoEscape;
      }
      if (options != null ? options.layout : void 0) {
        layout_options = {};
        for (k in options) {
          v = options[k];
          if (k !== "layout") {
            layout_options[k] = v;
          }
        }
      }
      _ref1 = this.runSync(filename, options), err = _ref1[0], res = _ref1[1];
      if (err && this.prettyPrintErrors) {
        _ref2 = [null, err], err = _ref2[0], res = _ref2[1];
      }
      if ((!err) && (layout_options != null)) {
        layout_options.body = res;
        _ref3 = this.runSync(options.layout, layout_options), err = _ref3[0], res = _ref3[1];
        if (err && this.prettyPrintErrors) {
          _ref4 = [null, err], err = _ref4[0], res = _ref4[1];
        }
      }
      return cb(err, res);
    };

    engine.prototype.runSync = function(filename, options) {
      /*
          "options" the same as run() above
      */

      var err, pwd, realpath, res, start_time, v, _ref1, _ref2,
        _this = this;
      start_time = Date.now();
      options = options || {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = options.__toffee.dir || process.cwd();
      filename = filename[0] !== "/" ? "" + options.__toffee.dir + "/" + filename : filename;
      realpath = path.normalize(filename);
      pwd = path.dirname(realpath);
      v = (this._viewCacheGet(realpath)) || (this._loadCacheAndMonitor(realpath, options));
      if (v) {
        options.__toffee.parent = realpath;
        options.partial = options.partial || function(fname, lvars) {
          return _this._fn_partial(fname, lvars, realpath, options);
        };
        options.snippet = options.snippet || function(fname, lvars) {
          return _this._fn_snippet(fname, lvars, realpath, options);
        };
        options.print = options.print || function(txt) {
          return _this._fn_print(txt, options);
        };
        if (!(options.console != null)) {
          options.console = {
            log: console.log
          };
        }
        _ref1 = v.run(options), err = _ref1[0], res = _ref1[1];
      } else {
        _ref2 = ["Couldn't load " + realpath, null], err = _ref2[0], res = _ref2[1];
      }
      this._log("" + realpath + " run in " + (Date.now() - start_time) + "ms");
      return [err, res];
    };

    engine.prototype._viewCacheGet = function(filename) {
      if (!(this.viewCache[filename] != null)) {
        return null;
      } else if (!(this.fsErrorCache[filename] != null)) {
        return this.viewCache[filename];
      } else if ((Date.now() - this.fsErrorCache[filename]) < tweakables.MISSING_FILE_RECHECK) {
        return this.viewCache[filename];
      } else {
        return null;
      }
    };

    engine.prototype._inlineInclude = function(filename, local_vars, parent_realpath, parent_options) {
      var err, k, options, res, v, _ref1;
      options = local_vars || {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = path.dirname(parent_realpath);
      options.__toffee.parent = parent_realpath;
      if (!options.__toffee.noInheritance) {
        for (k in parent_options) {
          v = parent_options[k];
          if (!((local_vars != null ? local_vars[k] : void 0) != null)) {
            if (!(k === "print" || k === "partial" || k === "snippet" || k === "layout" || k === "__toffee")) {
              options[k] = v;
            }
          }
        }
      }
      _ref1 = this.runSync(filename, options), err = _ref1[0], res = _ref1[1];
      return err || res;
    };

    engine.prototype._fn_snippet = function(fname, lvars, realpath, options) {
      lvars = lvars != null ? lvars : {};
      lvars.__toffee = lvars.__toffee || {};
      lvars.__toffee.noInheritance = true;
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_partial = function(fname, lvars, realpath, options) {
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_print = function(txt, options) {
      if (options.__toffee.state === states.COFFEE) {
        options.__toffee.out.push(txt);
        return '';
      } else {
        return txt;
      }
    };

    engine.prototype._loadCacheAndMonitor = function(filename, options) {
      var previous_fs_err, txt, v, view_options, _ref1;
      previous_fs_err = this.fsErrorCache[filename] != null;
      try {
        txt = fs.readFileSync(filename, 'utf8');
        if (this.fsErrorCache[filename] != null) {
          delete this.fsErrorCache[filename];
        }
      } catch (e) {
        txt = "Error: Could not read " + filename;
        if (((_ref1 = options.__toffee) != null ? _ref1.parent : void 0) != null) {
          txt += " first requested in " + options.__toffee.parent;
        }
        this.fsErrorCache[filename] = Date.now();
      }
      if (this.fsErrorCache[filename] && previous_fs_err && this.viewCache[filename]) {
        return this.viewCache[filename];
      } else {
        view_options = this._generateViewOptions(filename);
        v = new view(txt, view_options);
        this.viewCache[filename] = v;
        this._monitorForChanges(filename, options);
        return v;
      }
    };

    engine.prototype._reloadFileInBkg = function(filename, options) {
      var _this = this;
      return fs.readFile(filename, 'utf8', function(err, txt) {
        var v, view_options, _ref1;
        if (err || (txt !== _this.viewCache[filename].txt)) {
          if (err) {
            _this.fsErrorCache[filename] = Date.now();
            txt = "Error: Could not read " + filename;
            if (((_ref1 = options.__toffee) != null ? _ref1.parent : void 0) != null) {
              txt += " requested in " + options.__toffee.parent;
            }
          }
          if (!(err && _this.viewCache[filename].fsError)) {
            view_options = _this._generateViewOptions(filename);
            view_options.cb = function(v) {
              _this._log("" + filename + " updated and ready");
              return _this.viewCache[filename] = v;
            };
            if (err) {
              view_options.fsError = true;
            }
            return v = new view(txt, view_options);
          }
        }
      });
    };

    engine.prototype._generateViewOptions = function(filename) {
      return {
        fileName: filename,
        verbose: this.verbose,
        prettyPrintErrors: this.prettyPrintErrors,
        prettyLogErrors: this.prettyLogErrors,
        autoEscape: this.autoEscape,
        additionalErrorHandler: this.additionalErrorHandler,
        minimize: this.minimize
      };
    };

    engine.prototype._monitorForChanges = function(filename, options) {
      /*
          we must continuously unwatch/rewatch because some editors/systems invoke a "rename"
          event and we'll end up following the wrong, old 'file' as a new one
          is dropped in its place.
      
          Files that are missing are ignored here because they get picked up by new calls to _loadCacheAndMonitor
      */

      var fsw,
        _this = this;
      if (!(this.fsErrorCache[filename] != null)) {
        fsw = null;
        try {
          this._log("" + filename + " starting fs.watch()");
          return fsw = fs.watch(filename, {
            persistent: true
          }, function(change) {
            _this._log("" + filename + " closing fs.watch()");
            fsw.close();
            _this._monitorForChanges(filename, options);
            return _this._reloadFileInBkg(filename, options);
          });
        } catch (e) {
          this._log("fs.watch() failed for " + filename + "; settings fsErrorCache = true");
          return this.fsErrorCache[filename] = Date.now();
        }
      }
    };

    return engine;

  })();

  exports.engine = engine;

}).call(this);
