// Generated by CoffeeScript 1.12.2
(function() {
  var lex, lexer;

  lexer = require('./coffee-script/lexer');

  lex = new lexer.Lexer();

  exports.interpolateString = function(str) {

    /*
    Similar to the interpolateString function in CoffeeScript,
    except that it doesn't actually work on anything inside an outer #{};
    we're just looking to recognize them.
     */
    var expr, i, inner, interpolated, j, len, letter, pi, ref, res, tag, tokens, value;
    tokens = [];
    res = [];
    pi = 0;
    i = -1;
    while (letter = str.charAt(i += 1)) {
      if (letter === '\\') {
        i += 1;
        continue;
      }
      if (!(letter === '#' && str.charAt(i + 1) === '{' && (expr = lex.balancedString(str.slice(i + 1), '}')))) {
        continue;
      }
      if (pi < i) {
        tokens.push(['NEOSTRING', str.slice(pi, i)]);
      }
      inner = expr.slice(1, -1);
      if (inner.length) {
        tokens.push(['TOKENS', inner]);
      }
      i += expr.length;
      pi = i + 1;
    }
    if ((i > pi && pi < str.length)) {
      tokens.push(['NEOSTRING', str.slice(pi)]);
    }
    if (!tokens.length) {
      return res.push('STRING', '""');
    }
    if (tokens[0][0] !== 'NEOSTRING') {
      tokens.unshift(['', '']);
    }
    if (interpolated = tokens.length > 1) {
      res.push('(', '(');
    }
    for (i = j = 0, len = tokens.length; j < len; i = ++j) {
      ref = tokens[i], tag = ref[0], value = ref[1];
      if (i) {
        res.push('+', '+');
      }
      if (tag === 'TOKENS') {
        res.push([tag, value]);
      } else {
        res.push(['STRING', value]);
      }
    }
    if (interpolated) {
      res.push(')', ')');
    }
    return tokens;
  };

}).call(this);
